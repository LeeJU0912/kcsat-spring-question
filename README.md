# 스프링 AI 문제 생성 서버

## 사용 기술 스택
1. Spring Boot 3.3.4
2. Kafka

## 기술 이용
1. Kafka의 Offset 메타데이터를 활용하여 실시간 대기열 확인 기능을 구현.
2. 생성에 여러 개의 Topic을 사용하여 GPU 병렬 처리 진행 (파티션 단위로 하려고 했으나, DefaultPartitioner인 Sticky에서 RoundRobin으로 알고리즘을 바꾸어도 완전한 RoundRobin 처리를 하지 않는 문제점이 존재하였음. 추후 해결해야할 부분)
3. Spring Kafka Consumer는 Map\<UUID, Queue\<Message\>\> 형태로 만들어진 문제들에 대해 Session UUID로 분류하여 저장. Session이 삭제될 때, Map UUID의 모든 자료를 삭제하는 것으로 메모리 누수 방지.
4. 사용자가 결과를 받지 않고 여러 번 생성 요청을 하면, Queue의 나머지 메시지를 다 버리고 가장 마지막 요청 하나만을 수용함.

## 기술 도입에 대한 생각
1. 지금 구현된 기능으로는 버튼을 누르고 결과가 나오기를 기다려야 하는 동기적인 로직이지만, 생성을 누르고 다른 작업을 할 수 있도록 백그라운드에서 제작하고 반환하여 문제집에 자동으로 넣어주는 완전한 비동기 로직으로 설계하는 것도 고려할 수 있음.
2. Spring 커뮤니티 서버에는 JWT를 사용하였으나, 이 곳에서는 세션을 사용하였음. Redis를 JWT 저장소로 사용하게 된다면 세션 대신 JWT를 이용할 수 있도록 하여 보안성을 높이고, 회원 개인화 통계 정보를 저장할 수 있음. (현재 Question 서버는 사용자 인증 로직이 없는 상황)
3. Kafka를 단순히 생성 요청용으로만 사용하는 것이 아닌, 전체 시스템의 버스 역할로서 고부하시 레플리카 자동 수평 확장과 서버 부분 오류에도 대응이 매우 용이한 설계를 해보고 싶은 욕심이 있음.

## 핵심 구현 기능
1. AI 문제, 해설 생성
   - 문제, 해설 생성에 각각 2개의 GPU 서버가 구동 중인 상황.
   - 최초에 1회 접속하는 것으로 새로운 Session UUID 생성.
   - 2개의 서버에 번갈아가며 AI 생성 요청 시도 후 현재 자신의 Offset 위치 반환.
   - (현재 자신의 Offset - 최근 Consume된 Offset) 계산 API로 자신의 실시간 위치 확인.
   - 생성된 UUID를 기준으로 Queue에 데이터를 저장하고 가져옴.

---

![Kafka_Diagram.png](Kafka_Diagram.png)